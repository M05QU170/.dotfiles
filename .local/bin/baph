#!/bin/bash

# simple package installs

# CopyrightÂ© Nathaniel Maia <natemaia10@gmail.com> 2018-2020
# This program is provided free of charge and without warranty

# change to use a different build directory
typeset -r builddir="/tmp/baph/builds"

# aur http address
typeset -r auraddr='https://aur.archlinux.org'

use()
{ # show the manpage or version.
	[[ $1 == 'v' ]] && printf "baph-0.79\n" || man baph
}

msg()
{ # print colour $1 :: then message $2 in bold, usage: msg color text
	[[ $1 ]] && printf "\e[1m%b::\e[0m \e[1m$2\e[0m\n" "$1" || printf "%s\n" "$2"
}

die()
{ # print string $1 and exit with error code $2, usage: die "text" exitcode
	printf "\e[1;31merror:\e[0m %s\n" "$1" && exit "${2:-1}"
}

get()
{ # install an AUR package.. usage: get package
	rm -rf "$builddir/$1"
	cd "$builddir" || die "failed to cd to $builddir"

	if hash git >/dev/null 2>&1; then
		msg '\e[34m' "Cloning \e[32m$1\e[0m\e[1m package repo..."
		git clone "$auraddr/$1" || die "failed to clone package repo: $auraddr/$1"
	else
		msg '\e[34m' "Retrieving package archive: $1"
		rm -rf "$builddir/$1*"
		curl -LO#m 30 --connect-timeout 10 "$auraddr/cgit/aur.git/snapshot/$1.tar.gz"
		if [ $? -eq 0 ] && [[ -e "$1.tar.gz" ]] && tar -xvf "$1.tar.gz"; then
			rm -f "$builddir/$1.tar.gz"
		else
			die "failed to download and extract package: $1"
		fi
	fi

	if [[ -r "$builddir/$1/PKGBUILD" ]]; then
		view "$1" || yesno "Continue building $1" || { rm -rf "$builddir/$1"; return 1; }
		build "$1" || return 1
	else
		die "$builddir/$1 does not contain a PKGBUILD or it is not accessible"
	fi
	return 0
}

view()
{ # view the given PKGBUILD if noview is unset.. usage: view package
	if [[ -z $noview ]] && yesno "View/Edit the PKGBUILD for $1" 1; then
		${EDITOR:-vi} "$builddir/$1/PKGBUILD"
		return 1
	fi
	return 0
}

keys()
{ # import PGP keys from package.. usage: keys key1 key2 ...
	for k; do
		pacman-key --list-keys | grep -q "$k" && continue
		msg '\e[33m' "Resolving missing pgp key for $pkg: $k"
		if ! gpg --receive-keys "$k" && sudo pacman-key -r "$k" && sudo pacman-key --lsign-key "$k"; then
			msg '\e[33m' "Failed to import pgp key, continuing anyway"
		fi
	done
}

deps()
{ # build package depends.. usage: deps dep1 dep2 ...
	for d; do
		d="$(sed 's/[=<>]=\?[0-9.\-]*.*//g' <<< "$d")"
		if ! { pacman -Qsq "^$d$" || pacman -Ssq "^$d$"; } >/dev/null 2>&1; then
			msg '\e[33m' "Resolving \e[32m$pkg\e[0m\e[1m AUR dependency: $d"
			get "$d" || die "failed to build dependency $d"
		fi
	done
}

yesno()
{ # ask confirmation if noconf is not set, usage: yesno question
	[[ $noconf ]] && return 0
	read -re -p $'\e[34m::\e[0m \e[1m'"$1"$'? [Y/n]\e[0m ' c && [[ -z $c || $c == 'y' || $c == 'Y' ]]
}

query()
{ # return key value $1 from json dict $2, usage: query key input
	awk -F'","' -v k="$1" '{ for (i=1; i <= NF; i++) { if ($i ~ k) print $i } }' <<< "$2" |
		sed 's/.*'"$1"'":"\?\(.*\),\?"\?.*/\1/g; s/[,"]$//g; s/[\\%]//g; s/null,".*$/null/'
}

build()
{ # build package.. usage: build package
	typeset arrtext=""
	typeset -i in=0 out=0
	typeset -a depends=() makedepends=() validpgpkeys=()

	while read -r line; do # read the PKGBUILD and extract the depends, makedepends, and validpgpkeys arrays
		[[ $line =~ ^[\ \	]*# ]] && continue
		[[ $line =~ ^(depends=|makedepends=|validpgpkeys=) ]] && in=1
		[[ $line == *')'* && $in -eq 1 ]] && out=1
		(( in )) && arrtext+="$line"$'\n'
		(( out )) && out=0 in=0 # reset
	done < "$builddir/$1/PKGBUILD"

	eval "$arrtext" # FIXME: this is better than evaluating the whole PKGBUILD but still shit, is there a better way?

	keys "${validpgpkeys[@]}"
	deps "${depends[@]}" "${makedepends[@]}"
	cd "$builddir/$1" || die "failed to cd $builddir/$1"
	makepkg -sicr $noconf && { rm -rf ./*.tar.* >/dev/null 2>&1 || return 0; }
}

search()
{ # search query the AUR, usage: search "query"
	for q; do
		msg '\e[34m' "Searching AUR for '$q'...\n"
		typeset res="$(curl -sLm 30 --connect-timeout 10 "$auraddr/rpc.php?type=search&arg=${q}")"

		if [[ -z $res || $res == *'"resultcount":0'* ]]; then
			printf "\e[1;31m:: \e[0mno results found for '$q'\n"
		else
			typeset -i i=1
			typeset -a pkgs=()
			while read -r line; do
				n=$(query "Name" "$line")
				v=$(query "Version" "$line")
				d=$(query "Description" "$line")
				[[ $(query "OutOfDate" "$line") != null ]] && v+="\e[1;31m  (Out of Date!)"
				printf "\e[1;33m%s \e[1;37m%s \e[1;32m$v\n\e[0m    $d\n" "$i" "$n"
				(( i++ ))
			done < <(sed 's/},{/\n/g' <<< "$res")
		fi
	done
}

update()
{ # check updates for every package unless passed certain packages to update
	typeset -i i
	typeset -a up=()
	typeset p='' prnt=''
	noview='--noview'

	if (( ${#aurpkgs[@]} == 0 )); then
		mapfile -t aurpkgs < <(pacman -Qqm 2>/dev/null)
		[[ $auronly ]] || sudo pacman -Syyu $noconf
	fi

	if (( ${#aurpkgs[@]} == 0 )); then
		msg '\e[34m' "No AUR packages installed.."
	else
		msg '\e[34m' "Synchronizing AUR package versions..."
		typeset all="${aurpkgs[*]}"
		eval typeset -A old=($(pacman -Q "${aurpkgs[@]}" | awk '{print "["$1"]="$2}'))
		eval typeset -A new=($(curl -sLZm $((${#old[@]} * 15)) --connect-timeout 10 "$auraddr/packages/{${all// /,}}" |
			awk '/Package Details:/ {sub(/<\/h.?>/,""); print "["$3"]="$4}'))

		for p in "${aurpkgs[@]}"; do
			if [[ ${new[$p]} && ${old[$p]} && $(vercmp "${new[$p]}" "${old[$p]}") -gt 0 ]]; then
				up+=("$p")
				prnt+="${p}-${new[$p]} "
				(( i++ ))
			fi
		done

		if (( i )); then
			msg '\e[34m' "Starting AUR package upgrade..."
			printf "\n\e[1mPackages (%s)\e[0m %s\n\n" "$i" "$prnt"
			yesno "Proceed with package upgrade" && for pkg in "${up[@]}"; do get "$pkg"; done
		else
			msg '' " there is nothing to do"
		fi
	fi
}

install()
{ # loop over input packages and install each
	if (( ! ${#auronly} && ${#pacpkgs[@]} )); then
		sudo pacman -Syyu "${pacpkgs[@]}" $noconf || exit 1
	fi

	for pkg in "${aurpkgs[@]}"; do
		v=$(curl -sLIm 30 --connect-timeout 10 "$auraddr/packages/$pkg" | awk 'NR==1 && /HTTP/ {print $2}')
		if (( v >= 200 && v < 400 )); then
			get "$pkg" || msg '\e[33m' "Exited $pkg build early"
		else
			die "$auraddr/packages/$pkg responded $v, is the name spelled correctly"
		fi
	done
}

main()
{
	typeset cmd args
	typeset -g pkg
	typeset -A desc opts
	typeset -ga pacpkgs aurpkgs
	desc=(
		[s]='search' [u]='update' [i]='install'
	)
	opts=(
		[s]='cmd=search' [u]='cmd=update' [i]='cmd=install'
		[n]='noview=--noview' [N]='noconf=--noconfirm' [a]='auronly=--auronly'
	)
	for arg; do # shift long opts to short form
		case "$arg" in
			--version|--help|--search|--install|--update|--noview|--auronly|--noconfirm)
				[[ $arg == '--noconfirm' ]] && arg="${arg^^}"
				[[ $args == *"${arg:2:1}"* ]] || args+="${arg:1:2}" ;;
			--*) die "invalid option: '$arg'" ;;
			-*) [[ $args == *"${arg:1:1}"* ]] || args+="$arg " ;;
			*) [[ $args == *"$arg"* ]] || args+="$arg " ;;
		esac
	done
	eval set -- "$args"
	while getopts ":hvuisanN" OPT; do
		case "$OPT" in
			h|v) use "$OPT"; exit 0 ;;
			n|N|a|s|u|i)
				if [[ $OPT =~ (s|u|i) && $cmd == ${desc[$OPT]} ]]; then
					die "'${desc[$OPT]}' does not support being passed multiple times"
				elif [[ $OPT =~ (s|u|i) && $cmd && $cmd != ${desc[$OPT]} ]]; then
					die "'${desc[${cmd:0:1}]}' and '${desc[$OPT]}' can't be used together"
				fi
				eval "${opts[$OPT]}" ;;
			\?) die "invalid option: '$OPTARG'" ;;
		esac
	done
	shift $((OPTIND - 1))

	[[ $cmd ]] || die "no operation specified (use -h for help)"
	[[ $cmd == 'update' || $# -gt 0 ]] || die "no targets specified for ${desc[${cmd:0:1}]}"

	for arg; do # remaining args are considered packages
		if pacman -Ssq "^$arg$" >/dev/null 2>&1; then
			pacpkgs+=("$arg")
		else
			aurpkgs+=("$arg")
		fi
	done

	$cmd "$@"
}

(( UID )) || die "do not run $0 as root"
hash makepkg >/dev/null 2>&1 || die "$0 only supports systems that use pacman as their package manager"
hash sudo curl >/dev/null 2>&1 || die "$0 requires to following packages: sudo, curl\n\n\toptional packages: git"
mkdir -p "$builddir" || die "unable to create directory $builddir"

trap 'echo ^C; exit' INT
trap 'trap - INT' EXIT
main "$@"

# vim:fdm=marker:fmr={,}
